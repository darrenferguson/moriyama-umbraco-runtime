{
  "Name": "A runtime for Umbraco",
  "Type": "BlogPost",
  "CreateDate": "2015-06-14T20:27:43",
  "UpdateDate": "2015-06-14T21:11:14",
  "CreatorName": "Darren Ferguson",
  "WriterName": "Darren Ferguson",
  "Url": "http://localhost/2015/06/a-runtime-for-umbraco/",
  "RelativeUrl": "/2015/06/a-runtime-for-umbraco/",
  "Content": {
    "umbracoUrlAlias": "",
    "HideInNavigation": false,
    "umbracoInternalRedirectId": "",
    "redirect": "",
    "displayDate": "",
    "title": "A runtime for Umbraco",
    "shortUrl": "",
    "summary": "",
    "tags": "",
    "bodyText": "<p>It seems like an age ago now, but in 2013 I wrote about <a href=\"http://24days.in/umbraco/2013/mapping-content-to-pocos/\">mapping Umbraco content to POCO</a> and presented on the state of <a href=\"https://www.youtube.com/watch?v=U7dVUHtpd_k\">Umbraco and Azure</a> as I saw it at the time.</p>\n<p>I also wrote an article called <a href=\"http://blog.darren-ferguson.com/2013/11/18/my-three-circles-of-web-cms-nirvana/\">My three circles of Web CMS Nirvana</a> (I was into diagrams involving circles at the time). This article explained why I wanted a runtime for Umbraco and is probably good background reading for this post. But what I haven't mentioned until now, is that I went away and built the runtime. In fact you are using it now by reading this post.</p>\n<p>My blog is edited and deployed using Umbraco - but there is no Umbraco involved in the hosting of this site.</p>\n<p>I think I've covered the \"why\" in the previous post and this is more about the \"how\", but very briefly to recap:</p>\n<ul>\n<li>Memory use is a concern in hosting on some of the cheaper Azure websites - and having an in memory cache doesn't always work.</li>\n<li>Some of the Umbraco startup time tasks involve building that in memoey cache and associated Examine indexes - and in scalable applications launching new instances fast is important.</li>\n<li>Sometimes for really fast scalable apps that combine editorial structured content and user generated content Umbraco isn'e the right architecture.</li>\n</ul>\n<p>On the last point, joining Umbraco content and user generated content is difficult and slow if there is lots of user generated content, and the approach isn't very well thought out.</p>\n<p>I'm fresh back from Umbraco codegarden which is always inspiring and I'm pleased to see that lots of the ideas that I had around <a href=\"https://github.com/darrenferguson/cloud-umbraco-cache-refresh\">scaling Umbraco in Azure websites</a> are implemented in Umbraco 7.3. I know that there are ideas around a \"new cache\" which isn't a blob of XML in memory - but while we wait for that, I hope what I write here can provide some inspiration.</p>\n<p><strong>Part 1</strong></p>\n<p>So this is quite a meaty post which I intend to break into parts. And if you have the willpower to read My three circles of Web CMS Nirvana you'll be astute enough to realise that part 1 is <em><strong>\"to have your CMS output a bunch of files to disc, XML, JSON or whatever – but I’d specify that they should be files and not a database.\"</strong></em></p>\n<p>I plan to fully rant about how Umbraco shouldn't have a relational database in full detail at a later date.</p>\n<p>So this blog runs from JSON on a file system. The structure looks like this:</p>\n<p><img style=\"width: 500px; height: 373.26203208556154px;\" src=\"/media/1001/untitled.png?width=500&amp;height=373.26203208556154\" alt=\"\" rel=\"4134\" /></p>\n<p>The Umbraco tree just maps to a folder structure with a content.json file in each folder.</p>\n<p><strong>How?</strong></p>\n<p>With the implementation of a single interface that runs upon publish.</p>\n<pre class=\"brush: csharp;\">using Umbraco.Core.Models;\n\nnamespace Moriyama.Runtime.Umbraco.Interfaces\n{\n    public interface IUmbracoContentSerialiser\n    {\n        void Remove(IContent content);\n        void Serialise(IContent content);\n    }\n}</pre>\n<p>The task of the implementation is pretty simple. take the content and write it to disc.</p>\n<p>The implementation of <strong><em>IUmbracoContentSerialiser</em> </strong>hooks into the Umbraco publish, unpublish and delete events and has access to classes providing some other implementations of interfaces - most importantly <strong><em>IContentPathMapper</em> </strong>so it knows where to put the content on disc.</p>\n<pre class=\"brush: csharp;\">namespace Moriyama.Runtime.Interfaces\n{\n    public interface IContentPathMapper\n    {\n        string PathForUrl(string url, bool ensure);\n        ...\n</pre>\n<p>For me the only thing Umbraco should know about is IUmbracoContentSerialiser to keep the separation between CMS and runtime as clean cut as possible.</p>\n<p><strong>What does the JSON look like?</strong></p>\n<p>It looks like this (bodyText removed):</p>\n<pre>{\n  \"Name\": \"Create an Umbraco document with Perl and Web services\",\n  \"Type\": \"BlogPost\",\n  \"CreateDate\": \"2009-01-09T09:01:00\",\n  \"UpdateDate\": \"2015-01-19T18:41:22\",\n  \"CreatorName\": \"Darren Ferguson\",\n  \"WriterName\": \"Darren Ferguson\",\n  \"Url\": \"http://localhost/2009/1/9/create-an-umbraco-document-with-perl-and-web-services/\",\n  \"RelativeUrl\": \"/2009/1/9/create-an-umbraco-document-with-perl-and-web-services/\",\n  \"Content\": {\n    \"umbracoUrlAlias\": \"/create-an-umbraco-document-with-perl-and-web-services\",\n    \"HideInNavigation\": true,\n    \"umbracoInternalRedirectId\": \"\",\n    \"redirect\": \"\",\n    \"displayDate\": \"2009-01-09T09:01:00Z\",\n    \"title\": \"\",\n    \"shortUrl\": \"http://bit.ly/gqqMmf\",\n    \"summary\": \"'Create an Umbraco document with Perl and Web services' - a blog post by Darren Ferguson about document using Web services, media service, Perl, Technology Internet written on 09 January 2009\",\n    \"tags\": \"document using Web services, media service, Perl, Technology Internet\",\n    \"bodyText\": \"\",\n    \"commentsDisabled\": \"\"\n  },\n  \"Template\": \"Post\",\n  \"CacheTime\": null,\n  \"SortOrder\": 1,\n  \"Level\": 5\n}</pre>\n<p>The JSON serialised removes the Umbraco specific stuff which we don't use - like evil integer IDs and is easily serialised and de-serialised using NewtonSoft JSON to the following object:</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\n\nnamespace Moriyama.Runtime.Models\n{\n    public class RuntimeContentModel\n    {\n        public string Name { get; set; }\n        public string Type { get; set; }\n\n        public DateTime CreateDate { get; set; }\n        public DateTime UpdateDate { get; set; }\n\n        public string CreatorName { get; set; }\n        public string WriterName { get; set; }\n\n        public string Url { get; set; }\n        public string RelativeUrl { get; set; }\n        \n        public IDictionary&lt;string, object&gt; Content { get; set; }\n\n        public string Template { get; set; }\n        \n        public DateTime? CacheTime { get; set; }\n\n        public int SortOrder { get; set; }\n        public int Level { get; set; }\n    }\n}</pre>\n<p>In case you are wondering, we don't need Integer IDs or GUIDs, the relative URL is a perfectly good unique indentifier.</p>\n<p>The internals of mapping <em>IContent</em> to <em>RuntimeContentModel </em>are based around my article <a href=\"http://24days.in/umbraco/2013/mapping-content-to-pocos/\">mapping Umbraco content to POCO</a> (and I will share the source for all of this).<span style=\"text-decoration: underline;\"><br /></span></p>\n<p>One last thing here - <strong><em>IUmbracoContentSerialiser</em> </strong>discovers implementations of <em><strong>IUmbracoContentParser</strong> </em>with reflection and passes the <strong><em>RuntimeContentModel</em> </strong>through them before serialising to disc.</p>\n<pre class=\"brush: csharp;\">using Moriyama.Runtime.Models;\n\nnamespace Moriyama.Runtime.Umbraco.Interfaces\n{\n    public interface IUmbracoContentParser\n    {\n        RuntimeContentModel ParseContent(RuntimeContentModel model);\n    }\n}\n</pre>\n<p>An <strong><em>IUmbracoContentParser</em></strong> allows you to resolve and modify Umbraco properties. Here is a trivial implementation that renames umbracoNaviHide to something non Umbraco related - but more common uses would be to turn pickers that pick integer IDs into the relative URLs that I need.</p>\n<pre class=\"brush: csharp;\">using System.Linq;\nusing Moriyama.Runtime.Models;\nusing Moriyama.Runtime.Umbraco.Interfaces;\n\nnamespace Moriyama.Runtime.Umbraco.Application.Parser\n{\n    public class NaviHideUmbracoContentParser : IUmbracoContentParser\n    {\n        public RuntimeContentModel ParseContent(RuntimeContentModel model)\n        {\n            var newContent = model.Content.ToDictionary(entry =&gt; entry.Key, entry =&gt; entry.Value);\n\n            foreach (var property in model.Content)\n            {\n                if (property.Key != \"umbracoNaviHide\") continue;\n\n                var v = property.Value;\n                newContent.Remove(property.Key);\n\n                var newValue = v.ToString() != \"0\";\n                newContent.Add(\"HideInNavigation\", newValue);\n            }\n\n            model.Content = newContent;\n            return model;\n        }\n    }\n}\n</pre>\n<p>So I think that is more or less it for Part 1. I've got a disc full of JSON that I can send anywhere - and I can still use Umbraco as my CMS. I'm giving myself a pat on the back.</p>\n<p>In Part 2 - I'll look at how I can render this content as webpages in Umbraco templates. In part 3 I'll look at how to deploy this runtime into production without Umbraco, so I've truly separated my runtime and my CMS.</p>\n<p>For those of you still thinking Why? It is and edge case, definitely.</p>\n<p>And I'll leave you with some code - the implementation of <strong><em>IUmbracoContentSerialiser</em></strong> If you'd like access to the whole source - I'll put up the URL of the source of this blog on the next post. It is a little embarrassing just now and needs some polish:</p>\n<pre class=\"brush: csharp;\">using System.Collections.Generic;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing AutoMapper;\nusing log4net;\nusing Moriyama.Runtime.Models;\nusing Moriyama.Runtime.Umbraco.Interfaces;\nusing Umbraco.Core.Models;\nusing Umbraco.Web;\n\nnamespace Moriyama.Runtime.Umbraco.Application\n{\n    internal class UmbracoContentSerialiser : IUmbracoContentSerialiser\n    {\n        private static readonly ILog Logger = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);\n\n        private readonly UmbracoHelper _umbracoHelper;\n        private readonly IEnumerable _contentParsers;\n        \n        public UmbracoContentSerialiser(UmbracoHelper umbracoHelper, IEnumerable contentParsers)\n        {\n            _umbracoHelper = umbracoHelper;\n            _contentParsers = contentParsers;\n        }\n\n        public void Remove(IContent content)\n        {\n            var publishedContent = _umbracoHelper.TypedContent(content.Id);\n\n            if(publishedContent != null)\n                RuntimeContext.Instance.ContentService.RemoveContent(publishedContent.Url);\n        }\n\n        public void Serialise(IContent content)\n        {\n            var publishedContent = _umbracoHelper.TypedContent(content.Id);\n\n\n            if (publishedContent == null)\n                return;\n\n            var runtimeContent = Mapper.Map(publishedContent);\n\n            runtimeContent.Url = RemovePortFromUrl(publishedContent.UrlWithDomain());\n            runtimeContent.RelativeUrl = publishedContent.Url;\n            runtimeContent.CacheTime = null;\n\n            runtimeContent.Type = publishedContent.DocumentTypeAlias;\n\n            runtimeContent.Template = publishedContent.GetTemplateAlias();\n\n            runtimeContent.Content = new Dictionary&lt;string, object&gt;();\n\n            foreach (var property in content.Properties)\n            {\n                if (!runtimeContent.Content.ContainsKey(property.Alias))\n                    runtimeContent.Content.Add(property.Alias, property.Value);\n            }\n\n            foreach (var contentParser in _contentParsers)\n            {\n                runtimeContent = contentParser.ParseContent(runtimeContent);\n            }\n            \n            RuntimeContext.Instance.ContentService.AddContent(runtimeContent);\n        }\n\n        private string RemovePortFromUrl(string url)\n        {\n            var rgx = new Regex(@\"\\:\\d+\"); // get rid of any port from the URL\n\n            url = rgx.Replace(url, \"\");\n            return url;\n        }\n\n    }\n}</pre>",
    "commentsDisabled": 0
  },
  "Template": "Post",
  "CacheTime": null,
  "SortOrder": 0,
  "Level": 4
}