{
  "Name": "A runtime for Umbraco - Part 3",
  "Type": "BlogPost",
  "CreateDate": "2015-06-20T16:46:22",
  "UpdateDate": "2015-06-21T10:31:09",
  "CreatorName": "Darren Ferguson",
  "WriterName": "Darren Ferguson",
  "Url": "http://localhost/2015/06/20/a-runtime-for-umbraco-part-3/",
  "RelativeUrl": "/2015/06/20/a-runtime-for-umbraco-part-3/",
  "Content": {
    "umbracoUrlAlias": "",
    "HideInNavigation": false,
    "umbracoInternalRedirectId": "",
    "redirect": "",
    "displayDate": "",
    "title": "A runtime for Umbraco - Part 3",
    "shortUrl": "",
    "summary": "",
    "tags": "",
    "bodyText": "<p>And so on to part 3 - and the runtime has a name \"<em>Speedwagon</em>\".</p>\n<p>Since I last wrote, the project has become all hipster with Kevin offering up a Node implementation of the runtime at <a href=\"https://github.com/KevinJump/nodebraco.runtime.site\">https://github.com/KevinJump/nodebraco.runtime.site</a></p>\n<p>I've also bared my soul and published the source for the runtime at: <a href=\"https://github.com/darrenferguson/moriyama-umbraco-runtime\">https://github.com/darrenferguson/moriyama-umbraco-runtime</a></p>\n<p>This time, I want to write about the <strong><em>CacheLessRuntimeContentService</em> </strong>and show how we can get a piece of content from our  JSON files and make it available for an MVC view to render.<strong><br /></strong></p>\n<p>The default runtime controller does this:</p>\n<pre class=\"brush: csharp;\">var url = ctx.Request.Url;\nvar urlString = String.Format(\"{0}{1}{2}{3}\", url.Scheme, Uri.SchemeDelimiter, url.Authority, url.AbsolutePath);\n\nvar model = RuntimeContext.Instance.ContentService.GetContent(urlString);\n\nif (model != null)\n    return View(\"~/Views/\" + model.Template + \".cshtml\", model);\n \n\nResponse.StatusCode = 404;\nreturn View(\"~/Views/404.cshtml\", Build404Model(ctx.Request.Url));</pre>\n<p>Simplified into plain English this just means here is a URL, get me some content.</p>\n<p>The <strong><em>CacheLessRuntimeContentService</em> </strong>gets content from disc every time you ask for it. it also acts as a base class for other implementations of the content service which override certain methods to check in a content cache etc.</p>\n<pre class=\"brush: csharp;\">public virtual RuntimeContentModel GetContent(string url)\n{\n    url = ProcessUrlAliases(url);\n\n    Logger.Info(\"Got from disk \" + url);\n    var contentFile = PathMapper.PathForUrl(url, false);\n\n    if (!File.Exists(contentFile))\n    {\n        if (Removed != null)\n            Removed(url, new EventArgs());\n\n        return null;\n    }\n\n    var content = FromFile(contentFile);\n\n    if (Added != null)\n        Added(content, new EventArgs());\n            \n    return content;\n}</pre>\n<p>The <strong><em>PathMapper</em> </strong>is something I've mentioned previously which turns a URL into a path on disc and the <strong><em>FromFile</em> </strong>method just deserialises JSON. <strong><em>ProcessUrlAliases</em></strong> just swaps out the URL of the request with the URL that Umbraco runs on.</p>\n<p>In a cached content service <strong><em>GetContent</em> </strong>is overridden to look in the Cache and fall-back to the base method in the cache less implementation.</p>\n<p>So what is missing from Part 3 is traversal. I'm going to try and explain this in words, but it is probably best to peek into the source.</p>\n<p>Children are just content items that have a URL that begin with the same URL but contain one more Slash. Descendants are just content items that begin with the same URL. Root content is just content with a level of 1. Top navigation is just content with a Level of two. The logic is all really simple.</p>\n<p>To have access to this information, the runtime just maintains a file that contains a list of all URLs.</p>\n<p>For example. in a View I can do:</p>\n<pre class=\"brush: csharp;\">foreach (var page in Model.Home().Children().Where(page =&gt; page.Type == \"BlogTextPage\" &amp;&amp; !page.HideInNavigation()))</pre>\n<p>Under the hood <strong><em>Home</em></strong> does:</p>\n<pre class=\"brush: csharp;\">protected string HomeUrl(RuntimeContentModel model)\n{\n   var a = Urls.Where(x =&gt; model.Url.StartsWith(x)).OrderBy(x =&gt; x.Length);\n   return a.First();\n}</pre>\n<p>And <strong><em>Children</em> </strong>does:</p>\n<pre class=\"brush: csharp;\">protected IEnumerable ChildrenUrls(RuntimeContentModel model)\n{\n    return Urls.Where(x =&gt; x.StartsWith(model.Url) &amp;&amp; x != model.Url &amp;&amp; x.Split('/').Length == model.Url.Split('/').Length + 1);\n}</pre>\n<p>There are lots of efficiencies to be gained - but for now the logic is kind of readable.</p>\n<p>So a wrap for part 3 I think. Part 4 will be how to extend the default Runtime Controller, to do posting of blog comments and other form submissions. Part 5, implementation of cached content services, and part 6 what needs to be done to speed this up and make it integrate seamlessly with Umbraco.</p>\n<p>Thanks for your interest to date - I'd love your feedback on the source, but please go easy. I did rush it somewhat.</p>",
    "commentsDisabled": 0
  },
  "Template": "Post",
  "CacheTime": null,
  "SortOrder": 0,
  "Level": 5
}