{
  "Name": "More on auto linking key phrases in blog posts",
  "Type": "BlogPost",
  "CreateDate": "2009-01-07T09:37:00",
  "UpdateDate": "2015-01-19T18:41:22",
  "CreatorName": "Darren Ferguson",
  "WriterName": "Darren Ferguson",
  "Url": "http://localhost/2009/1/7/more-on-auto-linking-key-phrases-in-blog-posts/",
  "RelativeUrl": "/2009/1/7/more-on-auto-linking-key-phrases-in-blog-posts/",
  "Content": {
    "umbracoUrlAlias": "/more-on-auto-linking-key-phrases-in-blog-posts",
    "HideInNavigation": true,
    "umbracoInternalRedirectId": "",
    "redirect": "",
    "displayDate": "2009-01-07T09:37:00Z",
    "title": "",
    "shortUrl": "http://bit.ly/dGgYLb",
    "summary": "'More on auto linking key phrases in blog posts' - a blog post by Darren Ferguson about Perl, C, JSON, XSLT written on 07 January 2009",
    "tags": "Perl, C, JSON, XSLT",
    "bodyText": "<p>Following on from my previous post I had some more time to think\r\nabout how to implement automatic linking of key words and phrases\r\nwithin blog posts.</p><p>The comments on my previous post were very helpful and gave two\r\nalternatives as to when the links should be applied. My first step\r\nwas to come up with some configuration to drive the linking. I came\r\nup with the following JSON.</p><pre class=\"sh_javascript\" style=\"border: 1px solid black; background-color: #eeeeee; padding: 7px;\">\r\n\r\n{<br />\r\n    \"linkattribs\": {<br />\r\n      \"target\": \"blank\",<br />\r\n        \"class\": \"test\",<br />\r\n      \"onClick\": \"return clickHandler();\"<br />\r\n   },<br />\r\n    \"items\": [<br />\r\n        {<br />\r\n            \"phrases\": [<br />\r\n              \"Umbraco 4\", \"Umbraco\", \"Boost\"<br />\r\n           ],<br />\r\n            \"link\": \"http://www.umbraco.org/\",<br />\r\n            \"enabled\": true<br />\r\n       },<br />\r\n        {<br />\r\n         \"phrases\": [<br />\r\n              \"Me\", \"Darren\", \"Darren Ferguson\"<br />\r\n         ],<br />\r\n            \"link\": \"\",<br />\r\n           \"enabled\": true<br />\r\n       },<br />\r\n        {<br />\r\n         \"phrases\": [<br />\r\n              \"Liverpool\", \"The reds\"<br />\r\n           ],<br />\r\n            \"link\": \"http://www.liverpoolfc.tv/\",<br />\r\n         \"enabled\": true,<br />\r\n          \"linkattribs\": {<br />\r\n              \"onMouseOver\": \"liverpoolLinkHandler();\"<br />\r\n          }<br />\r\n     },<br />\r\n        {<br />\r\n         \"phrases\": [<br />\r\n              \"TinyMCE\"<br />\r\n         ],<br />\r\n            \"link\": \"http://tinymce.moxiecode.com/\",<br />\r\n          \"enabled\": true<br />\r\n       },<br />\r\n        {<br />\r\n         \"phrases\": [<br />\r\n              \"livewriter\", \"Live writer\"<br />\r\n           ],<br />\r\n            \"link\": \"http://windowslivewriter.spaces.live.com/\",<br />\r\n          \"enabled\": true<br />\r\n       },<br />\r\n        {<br />\r\n         \"phrases\": [<br />\r\n              \"livewriter\", \"Lucene\"<br />\r\n            ],<br />\r\n            \"link\": \"http://en.wikipedia.org/wiki/Lucene\",<br />\r\n            \"enabled\": true<br />\r\n       }<br />\r\n ]<br /><br />\r\n}<br /></pre><p>My next step was to quickly create some Perl code to apply the\r\nlinks to some markup (proof of concept before converting to\r\nC#).</p><pre class=\"sh_perl\" style=\"border: 1px solid black; background-color: #eeeeee; padding: 7px;\">\r\n\r\nuse strict;<br />\r\nuse utf8;<br /><br />\r\nuse JSON;<br />\r\nuse File::Slurp;<br />\r\nuse Data::Dumper;<br /><br />\r\nmy $post = read_file('post.txt') ;<br />\r\nmy $config = read_file('config.json');<br /><br />\r\n$config = from_json($config);<br /><br />\r\nforeach my $item (@{$config-&gt;{items}}) {<br /><br />\r\n  if($item-&gt;{enabled}) {<br /><br />\r\n      my $link = $item-&gt;{link};<br />\r\n      my $tag = build_link_tag($item-&gt;{link});<br /><br />\r\n      foreach my $phrase (@{$item-&gt;{phrases}}) {<br />\r\n         $phrase =~ s| |\\\\s\\+|gsm;<br />\r\n         $post =~ s|\\s($phrase)\\s| $tag$1&lt;/a&gt; |igsm;<br />\r\n     }<br />\r\n }<br />\r\n}<br /><br />\r\nprint $post;<br /><br />\r\nsub build_link_tag {<br /><br />\r\n  my $link = shift;<br />\r\n return qq(&lt;a href=\"$link\"&gt;);<br />\r\n}<br /></pre><p>Finally, the (untested) C# version.</p><pre class=\"sh_csharp\" style=\"border: 1px solid black; background-color: #eeeeee; padding: 7px;\">\r\n\r\nusing System;<br />\r\nusing System.Web;<br />\r\nusing System.Configuration;<br />\r\nusing System.IO;<br />\r\nusing System.Net.Json;<br />\r\nusing System.Text.RegularExpressions;<br /><br />\r\nnamespace FergusonMoriyama.ContentLinker<br />\r\n{<br />\r\n    public class Linker<br />\r\n    {<br />\r\n        public static String parseContent(String post) {<br /><br />\r\n            String umbPath = ConfigurationManager.AppSettings[\"umbracoPath\"];<br />\r\n            String configFile = HttpContext.Current.Server.MapPath(umbPath);<br /><br />\r\n            configFile = Path.Combine(configFile, @\"\\plugins\\FergusonMoriyama\\ContentLinker\\config.json\");<br />\r\n            StreamReader reader = File.OpenText(configFile);<br />\r\n            String configJson = reader.ReadToEnd();<br />\r\n            reader.Close();<br /><br />\r\n            JsonTextParser parser = new JsonTextParser();<br />\r\n            JsonObject configObj = parser.Parse(configJson);<br />\r\n            JsonObjectCollection config = (JsonObjectCollection)configObj;<br /><br />\r\n            JsonArrayCollection items = (JsonArrayCollection)config[\"items\"];<br /><br />\r\n            foreach (JsonObjectCollection item in items)<br />\r\n            {<br />\r\n                bool enabled = (bool)item[\"enabled\"].GetValue();<br />\r\n                if (enabled)<br />\r\n                {<br />\r\n                    String link = (String)item[\"link\"].GetValue();<br />\r\n                    String tag = \"&lt;a href=\\\"\" + link + \"\\\"&gt;\";<br />\r\n                    JsonArrayCollection phrases = (JsonArrayCollection)item[\"phrases\"];<br />\r\n                    foreach (JsonStringValue phrase in phrases)<br />\r\n                    {<br />\r\n                        String p = phrase.Value;<br />\r\n                        p = p.Replace(\" \", @\"\\s\\+\");<br /><br />\r\n                        // Console.WriteLine(p);<br />\r\n                        post = Regex.Replace(post, @\"\\s(\" + p + @\")\\s\", \" \" + tag + \"$1&lt;/a&gt; \");<br /><br />\r\n                    }<br />\r\n                }<br />\r\n            }<br /><br />\r\n            return post;<br /><br />\r\n        }<br />\r\n    }<br />\r\n}<br /></pre><p>This needs to be wrapped up as an Umbraco XSLT extension or get\r\ncalled as some sort of TinyMCE plug-in. I'll get around to this at\r\nsome point soon.</p><p>I added the ability to add attributes to links in the config but\r\nhaven't implemented these in the code just yet. Any further\r\ncomments and suggestions would be much appreciated. When I'm happy\r\nI'll make an Umbraco package and make it available for\r\neveryone.</p><p>Finally, one thing I noticed when testing this is that your\r\nlinks obviously get added in the order that they appear in\r\nconfiguration. If you have a phrase 'Umbraco' and 'Umbraco 4' in\r\nyour configuration 'Umbraco 4' would need to come first otherwise\r\nit would never be matched.</p>",
    "commentsDisabled": ""
  },
  "Template": "Post",
  "CacheTime": null,
  "SortOrder": 1,
  "Level": 5
}