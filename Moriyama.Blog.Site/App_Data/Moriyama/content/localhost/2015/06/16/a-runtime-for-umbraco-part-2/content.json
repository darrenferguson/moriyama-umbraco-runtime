{
  "Name": "A runtime for Umbraco - Part 2",
  "Type": "BlogPost",
  "CreateDate": "2015-06-16T17:08:10",
  "UpdateDate": "2015-06-16T17:08:10",
  "CreatorName": "Darren Ferguson",
  "WriterName": "Darren Ferguson",
  "Url": "http://localhost/2015/06/16/a-runtime-for-umbraco-part-2/",
  "RelativeUrl": "/2015/06/16/a-runtime-for-umbraco-part-2/",
  "Content": {
    "umbracoUrlAlias": "",
    "HideInNavigation": false,
    "umbracoInternalRedirectId": "",
    "redirect": "",
    "displayDate": "2015-06-16T19:14:11",
    "title": "A runtime for Umbraco - Part 2",
    "shortUrl": "",
    "summary": "",
    "tags": "",
    "bodyText": "<p>So before I start out on Part 2 - I should point out you need to read <a href=\"/2015/06/14/a-runtime-for-umbraco/\" title=\"A runtime for Umbraco\">part 1</a> for this to make any sense. Also thanks for the twitter reaction, we even have a PHP implementation of the runtime now by Gary at <a href=\"https://github.com/garydevenay/Moriyama-Runtime-PHP\">https://github.com/garydevenay/Moriyama-Runtime-PHP</a></p>\n<p>I should also point out that the interfaces detailed in part 1 are not part of the Umbraco core - I just hook into the regular Umbraco events to call my own implementations of my custom interfaces.</p>\n<p><strong>I can't fight this feeling any longer</strong></p>\n<p>At the end of part 1, I had all of my Umbraco content serialised to disc ready to push to a webapp that didn't have any Umbraco dependencies. But this whole system would be a little useless if I couldn't view my pages from within Umbraco before pushing them to the runtime.</p>\n<p>Fortunately Umbraco has excellent support for registering custom routes and overriding the default Umbraco routing:</p>\n<pre class=\"brush: csharp;\">namespace Moriyama.Runtime.Umbraco.Events\n{\n    public class RuntimeApplicationEventHandler : IApplicationEventHandler\n    {\n        private static readonly ILog Logger = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);\n\n        public void OnApplicationStarting(UmbracoApplicationBase umbracoApplication, ApplicationContext applicationContext)\n        {\n            DefaultRenderMvcControllerResolver.Current.SetDefaultControllerType(typeof(RuntimeUmbracoController));\n        }</pre>\n<p>An <strong><em>IApplicationEventHandler</em> </strong>is discovered by Umbraco upon start up and Umbraco provides the <strong><em>SetDefaultControllerType</em></strong><em> </em>method that allows you to use your own controller to handle requests to the front end website. This means that you can return views using any kind of Model that you wish.</p>\n<p>So we'll take a look at the definition of <strong><em>RuntimeUmbracoController:</em></strong></p>\n<pre class=\"brush: csharp;\">using System.Web.Mvc;\nusing Moriyama.Runtime.Controllers;\nusing Umbraco.Web.Models;\nusing Umbraco.Web.Mvc;\n\nnamespace Moriyama.Runtime.Umbraco.Controllers\n{\n    public class RuntimeUmbracoController : RenderMvcController\n    {\n        private readonly RuntimeController _runtimeController;\n\n        public RuntimeUmbracoController()\n        {\n            _runtimeController = new RuntimeController();\n        }\n\n        [OutputCache(CacheProfile = \"Standard\")]\n        public override ActionResult Index(RenderModel model)\n        {\n            return _runtimeController.Index();\n        }\n    }\n}</pre>\n<p>At first this seems a bit odd, it is really just a proxy to another controller. I do this because the default Umbraco Controller needs to inherit from <strong><em>RenderMvcController</em></strong><em> </em>so when we detach from Umbraco we need to remove that dependency and just use a regular MVC controller.</p>\n<p><em><strong>RuntimeController</strong> </em>looks like this:</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Web.Mvc;\nusing Moriyama.Runtime.Models;\n\nnamespace Moriyama.Runtime.Controllers\n{\n    public class RuntimeController : Controller\n    {\n        public ActionResult Index()\n        {\n            var ctx = System.Web.HttpContext.Current;\n           \n            var url = ctx.Request.Url;\n            var urlString = String.Format(\"{0}{1}{2}{3}\", url.Scheme, Uri.SchemeDelimiter, url.Authority, url.AbsolutePath);\n\n            var model = RuntimeContext.Instance.ContentService.GetContent(urlString);\n\n            if (model != null)\n            {\n                return View(\"~/Views/\" + model.Template + \".cshtml\", model);\n            }\n\n            Response.StatusCode = 404;\n            return View(\"~/Views/404.cshtml\", Build404Model(ctx.Request.Url));\n        }\n\n        private RuntimeContentModel Build404Model(Uri url)\n        {\n            var homeUrl = url.Scheme + \"://\" + url.Host + \":\" + url.Port + \"/\";\n            var content = RuntimeContext.Instance.ContentService.GetContent(homeUrl);\n\n            if (content == null)\n            {\n                content = new RuntimeContentModel();\n                content.Name = \"404 Not Found\";\n            }\n\n            return content;\n        }\n      \n    }\n}</pre>\n<p>From the above you can see how we render a page based on a template - just like Umbraco does, but using the <strong><em>RuntimeContentModel</em> </strong>defined in part 1. But the question that the controller raises is what is <strong><em>ContentService</em></strong><em> </em>and how does it use our JSON.</p>\n<p><strong>You give my life direction</strong></p>\n<p>Before I delve into the content service I need to quickly explain the structure of the Visual Studio solution:</p>\n<p><img style=\"width: 292px; height: 235px;\" src=\"/media/1002/untitled.png?width=292&amp;height=235\" alt=\"\" rel=\"4140\" /></p>\n<ul>\n<li>Moriyam.Blog.Umbraco - is Umbraco installed with Nuget</li>\n<li>Moriyama.Blog.Site - is my MVC application that I will eventually deploy to Azure websites as the runtime</li>\n<li>Moriyama.Blog.Runtime.Umbraco - Stuff to serialise content and route requests within Umbraco to my controllers</li>\n<li>Moriyama.Runtime - Runtime generics including the above <strong><em>RuntimeController </em></strong></li>\n<li>Moriyama.Runtime.Project - Controllers specific to this project</li>\n<li>Moriyama.Blog.Test - erm, nothing really</li>\n</ul>\n<p><strong>And even as I wander I'm keeping you in sight</strong></p>\n<p>So back to the <em><strong>ContentService</strong> </em>- more specifically:</p>\n<pre class=\"brush: csharp;\">using System;\nusing System.Collections.Generic;\nusing System.Web;\nusing Moriyama.Runtime.Models;\n\nnamespace Moriyama.Runtime.Interfaces\n{\n    public delegate void ContentAddedHandler(RuntimeContentModel sender, EventArgs e);\n    public delegate void ContentRemovedHandler(string sender, EventArgs e);\n\n    public interface IContentService\n    {\n        event ContentAddedHandler Added;\n        event ContentRemovedHandler Removed;\n\n        void AddContent(RuntimeContentModel model);\n        void RemoveContent(string url);\n\n        IEnumerable GetUrlList();\n\n        RuntimeContentModel GetContent(HttpContext context);\n        string GetContentUrl(HttpContext context);\n\n        RuntimeContentModel GetContent(string url);\n        RuntimeContentModel Home(RuntimeContentModel model);\n\n        IEnumerable TopNavigation(RuntimeContentModel model);\n        IEnumerable Children(RuntimeContentModel model);\n\n        IEnumerable Descendants(RuntimeContentModel model);\n        IEnumerable Descendants(RuntimeContentModel model, IDictionary&lt;string, string&gt; filter);\n\n        RuntimeContentModel CreateContent(string url, IDictionary&lt;string, object&gt; properties);\n    }\n}</pre>\n<p>There is lots in here ahead of part 3 but for now the significant part is that it can get content based on a URL - specifically <em>RuntimeContentModel GetContent(string url);</em></p>\n<p>For those of you familiar with writing Umbraco templates you should also see the potential to write extension methods for Descendants etc, which we need for a nice fluent template authoring experience.</p>\n<p><strong>It's time to bring this ship into the shore</strong></p>\n<p>To conclude part two - I'll mention that there are a few reference implementations of <strong>IContentService:</strong></p>\n<ul>\n<li>CacheLessRuntimeContentService - Reads JSON from disc as the content is requested</li>\n<li>CachedRuntimeContentService - Extends the above, placing the content into an expiring memory cache</li>\n<li>LuceneQueryingContentService - Experimental and a bit crazy, but often quicker than a memory cache</li>\n</ul>\n<p>As we are still previewing pages in Umbraco at this stage we'll normally stick with the <strong><em>CacheLessRuntimeContentService</em> </strong>and it works for small websites too, but as we move forward, this service can be swapped out in configuration - and the deployed runtime app would likely be Lucene based or memory cached.</p>\n<p><strong>And throw away the oars</strong></p>\n<p>In part 3 - I'll either talk about the implementation of the <strong><em>CacheLessRuntimeContentService</em></strong><em> </em>or talk about how to extend <strong><em>RuntimeController </em></strong>to do more complex things than render a piece of content. Obviously on this blog we have comments, and search and we need more than our <strong><em>RuntimeContentModel</em> </strong>to send data back and forth.<em><br /></em></p>\n<p>It'll depend on the mood I'm in next time I sit down to write.</p>\n<p><strong>Forever</strong></p>\n<p>Thanks for reading and apologies for the not completely random headings. And I'm not withholding code, DM me on Twitter if you'd like access to the repo. I need to tidy lots to make it all readable :)</p>",
    "commentsDisabled": 0
  },
  "Template": "Post",
  "CacheTime": null,
  "SortOrder": 0,
  "Level": 5
}