{
  "Name": "My three circles of Web CMS Nirvana",
  "Type": "BlogPost",
  "CreateDate": "2013-11-18T17:57:31",
  "UpdateDate": "2013-11-18T19:15:55",
  "CreatorName": "darrenf",
  "WriterName": "darrenf",
  "Url": "http://localhost/2013/11/18/my-three-circles-of-web-cms-nirvana/",
  "RelativeUrl": "/2013/11/18/my-three-circles-of-web-cms-nirvana/",
  "Content": {
    "umbracoUrlAlias": "",
    "HideInNavigation": false,
    "umbracoInternalRedirectId": "",
    "redirect": "",
    "displayDate": "2013-11-18T18:00:00Z",
    "title": "My three circles of Web CMS Nirvana",
    "shortUrl": "",
    "summary": "",
    "tags": "CMS, WCM, deployment, Umbraco",
    "bodyText": "<p><em>This post is highly subjective.</em></p>\r\n<p>My web CMS architecture separates into 3 circles, Content Management Deployment and Runtime.</p>\r\n<p><img width=\"500\" height=\"153\" src=\"/media/133570/circles_500x153.jpg\" alt=\"Circles\"/></p>\r\n<p>The three should be able to operate entirely independently of one another though in an ideal world the Runtime and Content Management may co-exist, for preview of content in the CMS authoring environment.</p>\r\n<p><em><strong>Content Management</strong></em></p>\r\n<p>Take the first circle – content management. It should perform the following roles.</p>\r\n<ul>\r\n<li>Authentication and Authorisation (Login to the CMS, control which editors can edit what)</li>\r\n<li>Versioning (maintain historical content – allow rollback)</li>\r\n<li>Content and Data types (what content is to be captured and how it should be structured)</li>\r\n<li>Content Entry (the user interface that is used to enter the content)</li>\r\n</ul>\r\n<p><img width=\"365\" height=\"371\" src=\"/media/133571/circles2.png\" alt=\"Circles2\"/></p>\r\n<p>Obviously – I am simplifying here. Some CMS may also have some kind of workflow component that defines a process for publishing content.</p>\r\n<p><em><strong>Deployment</strong></em></p>\r\n<p>So with the key point of this post being that <em><strong>the three circles should be able to operate entirely independently of one another </strong></em>it follows that they must communicate in some way.</p>\r\n<p>The job of the deployment circle is: <strong><em>To provide the latest version of all content to the runtime(s).</em></strong></p>\r\n<p>I’d say the best way to achieve this is to have your CMS output a bunch of files to disc, XML, JSON or whatever – but I’d specify that they should be files and not a database.</p>\r\n<p><em><strong>Why?</strong></em></p>\r\n<p>For two reasons. First the problem of synchronising files between two places is a problem that has been solved a million times over.</p>\r\n<ul>\r\n<li>Dropbox</li>\r\n<li>Bit Torrent Sync</li>\r\n<li>RoboCopy</li>\r\n<li>RSync</li>\r\n</ul>\r\n<p>Synchronising relational databases isn't so easy.</p>\r\n<p>The second reason is that text files are really easy to open up, poke around in, version with GIT, Mercurial etc.</p>\r\n<p>I have a reference file format if you are interested – but at this point we should be discarding historical versions of content and information about who authored it – because the deployment and the runtime circles just don’t care about this.</p>\r\n<p><em><strong>No SQL</strong></em></p>\r\n<p>I’m not into having a relational database anywhere in my ideal CMS architecture. It complicates initial setup – have to install the database, create a schema, setup connection string and so on. If you think cloud, it also makes provisioning new instances of your runtime web application more complicated.</p>\r\n<p>It also removes my ability to use my editor/tooling of my choice if my data type definition is hidden away in a relational database.</p>\r\n<p><em><strong>Runtime</strong></em></p>\r\n<p>The beauty of having a runtime that just receives a bunch of files is that your CMS could be an ASP.NET web application and your runtime could be Java, PHP or whatever you wished.</p>\r\n<p><img width=\"379\" height=\"362\" src=\"/media/133572/circles3.png\" alt=\"Circles3\"/></p>\r\n<p><em><strong>Umbraco</strong></em></p>\r\n<p>You may know that I work with Umbraco a lot – and I’ve started to apply some of these concepts to Umbraco.</p>\r\n<p>Upon publish we can serialise our Umbraco content to XML. All integer ID’s are replaced with (X)Paths and property values are scanned for ID’s which again are replaced with paths – this allows Umbraco picker data types to function correctly.</p>\r\n<p>Each node serialises to one XML file – the file is placed in a folder that corresponds to the path within the content hierarchy.</p>\r\n<p>This puts us in a state where we can synchronise this output folder to another file system – but remember that is the job of our deployment circle.</p>\r\n<p>We also discover instances of our <strong><em>ContentConvertor</em> </strong>interface at this point, in case we want something other than the DMCF XML that we output (Darren’s made up content format TM), in theory we could have our content represented as XML, JSON, generated as static HTML etc.</p>\r\n<p>Unfortunately this means that we have to write our own runtime “circle”. Umbraco presentation APIs are tied to the Umbraco cache and underlying database schema to some extent. Luckily we can add our own runtime into Umbraco for preview easily – using route hijacking.</p>\r\n<p><em><strong>What is missing?</strong></em></p>\r\n<p>In short, loads. By removing the Umbraco runtime from our front end site we lose.</p>\r\n<ul>\r\n<li>A content cache</li>\r\n<li>Examine Indexes</li>\r\n<li>Membership</li>\r\n<li>Relations</li>\r\n<li>And lots more….</li>\r\n</ul>\r\n<p>So for 90%+ of cases we’ll use Umbraco.</p>\r\n<p><em><strong>Why do all of this?</strong></em></p>\r\n<p>Mainly to ease some of the complexity of deploying code and content changes into environments. The ability to easily promote and demote code and content just by moving files around is really powerful. It also enables us to build massively scalable websites, that auto scale easily.</p>\r\n<p>Our runtime instances are agnostic of one another, there could be 1 or there could be 500, it just doesn’t matter.</p>\r\n<p><strong><em>Umbraco is a Swiss army knife and sometimes we just need the corkscrew.</em></strong></p>\r\n<p>Recently a client (a big one) did a (snail) mailshot to 20 million people. They couldn’t auto scale their call centre so they put a URL on the mailing instead.</p>\r\n<p>The issue here is that they needed to handle (very) high traffic for approximately 10 days. A month later the site was decommissioned completely.</p>\r\n<p>Given that we didn’t need Search, Login etc it was much easier to build a vanilla website with a few MVC Views, some CSS and JavaScript.</p>\r\n<p>Inside the client network – they have a single server running several Umbraco instances, but when they publish, it just writes some files that are sent to the runtime. It works really well and deals with hundreds of thousands of page view per day.</p>\r\n<p><em><strong>If massively scalable websites are something you want to do, <a href=\"http://www.moriyama.co.uk/contact-us/\">give me a call</a>.</strong></em></p>\r\n<p align=\"center\"> </p>",
    "commentsDisabled": 0
  },
  "Template": "Post",
  "BuildTime": "2015-01-02T16:36:47.6393898+00:00",
  "FromCache": false,
  "SortOrder": 0,
  "Level": 5
}